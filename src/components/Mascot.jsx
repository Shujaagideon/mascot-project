/* eslint-disable react/prop-types */
/* eslint-disable react/no-unknown-property */
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.3 mascot.glb --transform
*/

import { useGLTF } from '@react-three/drei';
import React from 'react';
import {editable as e} from '@theatre/r3f';
import * as THREE from 'three';
import glossyTex from '../assets/glossy2.jpg';
import tex from '../assets/beam.png';
import brushTex from '../assets/drawing2.png';
import sideDots from '../assets/tex2.png';
import disp from '../assets/disp1.jpg';
import metal from '../assets/metal.jpg';
import { types as t } from "@theatre/core";
import { useFrame, useLoader, useThree } from '@react-three/fiber';

const loader = new THREE.TextureLoader()

const texture = loader.load(glossyTex);
texture.colorSpace = THREE.SRGBColorSpace;

const texture2 = loader.load(brushTex);
texture2.colorSpace = THREE.SRGBColorSpace;

const texture3 = loader.load(metal);
texture3.colorSpace = THREE.SRGBColorSpace;
texture3.wrapS = THREE.RepeatWrapping
texture3.wrapT = THREE.RepeatWrapping

const texture4 = loader.load(sideDots);
texture4.colorSpace = THREE.SRGBColorSpace;

const displacement = loader.load(disp);
texture4.colorSpace = THREE.SRGBColorSpace;

const uniforms = {
  opacity: { value: 0. },
  material1: { value: 0. },
  material2: { value: 0. },
  material3: { value: 0. },
  time: { value: 0. },
  uTexture: { value: texture },
  uTexture2: { value: texture2 },
  uTexture3: { value: texture3 },
  uTexture4: { value: texture4 },
  displacement: { value: displacement },
  width: {value: 0.5},
  scaleX: {value: 40},
  scaleY: {value: 40},
  lightPos: {value: new THREE.Vector3(-1., -.2, -.8)},
  clampVal: {value: new THREE.Vector2(0., 1.)}
}

const shader = new THREE.ShaderMaterial({
  uniforms,
  transparent: true,
  vertexShader: /*glsl*/`
    varying vec3 vNormal;
    varying vec3 vPosition;
    varying vec2 vUv;
  
    void main() {
      vUv = uv;
      vNormal = normal;
      vPosition = position;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader:/*glsl*/`
    varying vec3 vNormal;
    varying vec3 vPosition;
    varying vec2 vUv;

    uniform sampler2D uTexture;
    uniform sampler2D uTexture2;
    uniform sampler2D uTexture3;
    uniform sampler2D uTexture4;
    uniform sampler2D displacement;
    uniform vec3 lightPos;
    uniform vec2 clampVal;
    uniform float material1;
    uniform float material2;
    uniform float material3;
    uniform float opacity;
    uniform float width;
		uniform float scaleX;
		uniform float scaleY;
		uniform float time;


    vec2 mirrored(vec2 v) {
			vec2 m = mod(v,2.);
			return mix(m,2.0 - m, step(1.0 ,m));
		}

    void main() {
        float light = dot(vNormal, normalize(lightPos)) * 0.5 + 0.5;
        light = clamp(light, clampVal.x, clampVal.y) * opacity;

        vec4 glossyMat = texture2D(uTexture, vUv);
        vec4 glossyColor = vec4(glossyMat.xyz, light);

        vec4 brushMat = texture2D(uTexture2, vUv);
        vec4 brushColor = vec4(brushMat.xyz, light);

        vec4 metalMat = texture2D(uTexture3, vUv) * 1.3;
        vec4 dotMat = texture2D(uTexture4, vUv);

        vec4 noise = texture2D(displacement, mirrored(vUv+time*0.04));
        float prog = material1*0.8 -0.05 + noise.g * 0.06;
        float prog1 = material2*0.8 -0.05 + noise.g * 0.06;
        float prog2 = material3*0.8 -0.05 + noise.g * 0.06;
        
        float intpl = pow(abs(smoothstep(0., 1., (prog*2. - vUv.y + 0.5))), 10.);
        float intpl1 = pow(abs(smoothstep(0., 1., (prog*2. - vUv.y + 0.5))), 10.);
        float intpl2 = pow(abs(smoothstep(0., 1., (prog*2. - vUv.y + 0.5))), 10.);

        vec4 mixMat = mix(metalMat, dotMat, light);

        vec4 part1 = mix(vec4(light),brushColor, intpl*material1);
        vec4 part2 = mix(part1, glossyColor, intpl1*material2);
        vec4 final = mix(part2, mixMat, intpl2*material3);
        gl_FragColor = final;
    }
  `,
})

export function Mascot({material, sheet, reference}) {
  const ref = React.useRef();
  const ref3 = React.useRef();
  const refBeam = React.useRef();
  const texture = useLoader(THREE.TextureLoader, tex);
    texture.colorSpace = THREE.SRGBColorSpace;
  const { nodes, materials } = useGLTF('/mascot-transformed.glb');
  const [changer, setChanger] = React.useState(0);
  const { viewport } = useThree()
  
  useFrame(({clock, mouse})=>{
    uniforms.time.value = clock.getElapsedTime();

    const x = (mouse.x * viewport.width) / 2;
    const y = (mouse.y * viewport.height) / 2;
    
    // ref.current.position.set(x, y, 0)
    ref.current.rotation.x = ref.current.rotation.x;
    ref.current.rotation.y = ref.current.rotation.y;
  })
    

  const mascotMat = sheet.object('MascotMaterial',{
    opacity: t.number(0, {
        nudgeMultiplier: 0.1,
        range: [0, 1]
    }),
    beamOpacity: t.number(0, {
      nudgeMultiplier: 0.1,
      range: [0, 1]
    }),
    clamp:{
      x: t.number(0, {
        nudgeMultiplier: 0.1,
        range: [0, 1]
      }),
      y: t.number(0, {
        nudgeMultiplier: 0.1,
        range: [0, 2]
      })
    },
    mat1: t.number(0, {
      nudgeMultiplier: 0.1,
      range: [0, 1]
    }),
    mat2: t.number(0, {
      nudgeMultiplier: 0.1,
      range: [0, 1]
    }),
    mat3: t.number(0, {
      nudgeMultiplier: 0.1,
      range: [0, 1]
    }),
    materialChanger: t.number(0, {
      nudgeMultiplier: 1,
      range: [-0.1, 2.2]
    }),
    sunSetter: t.boolean(true),
    lightPos: {
      x: uniforms.lightPos.value.x,
      y: uniforms.lightPos.value.y,
      z: uniforms.lightPos.value.z
    },
    
  },{reconfigure: true});

  React.useEffect(()=>{
    mascotMat.onValuesChange(val=>{
      uniforms.opacity.value = val.opacity;
      uniforms.clampVal.value.x = val.clamp.x;
      uniforms.clampVal.value.y = val.clamp.y;
      uniforms.material1.value = val.mat1;
      uniforms.material2.value = val.mat2;
      uniforms.material3.value = val.mat3;
      uniforms.lightPos.value.x = val.lightPos.x;
      uniforms.lightPos.value.y = val.lightPos.y;
      uniforms.lightPos.value.z = val.lightPos.z;

      ref3.current.opacity = val.beamOpacity
      shader.needsUpdate = true
      setChanger(val.materialChanger);
      if(val.materialChanger <= 0){
        ref.current.material = material
      }
      else if(val.materialChanger === 1 || val.materialChanger > 0 && val.materialChanger < 2){
        ref.current.material = shader
      }
      else if(val.materialChanger > 1.8){
        ref.current.material = materials['Tooth_Mixed_Material_2.004']
      }
    })

  },[mascotMat]);
  
  return (
    <e.group theatreKey='mascotPeople'>
      <e.group theatreKey='Mascot' dispose={null} ref={reference}>
        <mesh geometry={nodes.Sphere_1.geometry} ref={ref} position={[0, 2, 0]} rotation={[Math.PI / 2, 0, 0]}/>
        <group position={[0, -20, -35]}>
            <e.mesh theatreKey='planetsBeam' ref={refBeam} scale={[0.43, 0.62, 0]} position={[0, 28.47, 10.21]}>
                <planeGeometry args={[15,110]}/>
                <meshBasicMaterial ref={ref3} map={texture} side={THREE.DoubleSide} transparent depthWrite={false} depthTest={false}/>
            </e.mesh>
        </group>
      </e.group>
    </e.group>
  )
}

useGLTF.preload('/mascot-transformed.glb');
