/* eslint-disable react/prop-types */
/* eslint-disable react/no-unknown-property */
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.3 mascot.glb --transform
*/

import { useGLTF } from '@react-three/drei';
import React from 'react';
import {editable as e} from '@theatre/r3f';
import * as THREE from 'three';
import glossyTex from '../assets/glossy2.jpg';
import { useLoader } from '@react-three/fiber';
import { types as t } from "@theatre/core";


var vertexShader = `
  varying vec3 vNormal;
  varying vec2 vUv;

  void main() {
    vUv = uv;
    vNormal = normalize(normalMatrix * normal);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

// Fragment Shader
var fragmentShader = `
  varying vec3 vNormal;
  varying vec2 vUv;
  uniform sampler2D uTexture;
  uniform vec3 lightPos;
  uniform vec2 clampVal;
  uniform float material1;
  uniform float material2;
  uniform float transparencyFactor;

  void main() {
    float light = dot(vNormal, normalize(lightPos)) * 0.6 + 0.5;
    // light = clamp(light, clampVal.x, clampVal.y) * transparencyFactor;
    light = clamp(light, clampVal.x, clampVal.y);

    vec4 glossyMat = texture2D(uTexture, vUv);
    vec4 glossyColor = vec4(glossyMat.xyz, light);
    
    vec4 part1 = mix(vec4(light), glossyColor, material1) * transparencyFactor;
    vec4 part2 = mix(part1, vec4(light), material2);
    vec4 final = mix(part2, part1, material2);
    gl_FragColor = vec4(light);
  }
`;

export function Mascot({material, sheet}) {
  const ref = React.useRef();
  const { nodes, materials } = useGLTF('/mascot-transformed.glb');

  const texture = useLoader(THREE.TextureLoader, glossyTex);
  texture.colorSpace = THREE.SRGBColorSpace;

  const uniforms = {
    transparencyFactor: { value: 0. },
    material1: { value: 0. },
    material2: { value: 0. },
    uTexture: { value: texture },
    lightPos: {value: new THREE.Vector3(-1., -.2, -.8)},
    clampVal: {value: new THREE.Vector2(0., 1.)}
    // cameraPosition: { value: camera.position } // Pass camera position to the shader
  }

  const mascotMat = sheet.object('MascotMaterial',{
    transparencyFactor: t.number(uniforms.transparencyFactor.value, {
        nudgeMultiplier: 0.1,
        range: [0, 1]
    }),
    clamp:{
      x: t.number(0, {
        nudgeMultiplier: 0.1,
        range: [0, 1]
      }),
      y: t.number(0, {
        nudgeMultiplier: 0.1,
        range: [0, 1]
      })
    },
    mat1: t.number(0, {
      nudgeMultiplier: 0.1,
      range: [0, 1]
    }),
    mat2: t.number(0, {
      nudgeMultiplier: 0.1,
      range: [0, 1]
    }),
    lightPos: {
      x: uniforms.lightPos.value.x,
      y: uniforms.lightPos.value.y,
      z: uniforms.lightPos.value.z
    },
  },{reconfigure: true});

  React.useEffect(()=>{
    mascotMat.onValuesChange(val=>{
        uniforms.transparencyFactor.value = val.transparencyFactor;
        uniforms.clampVal.value.x = val.clamp.x;
        uniforms.clampVal.value.y = val.clamp.y;
        uniforms.material1.value = val.mat1;
        uniforms.material2.value = val.mat2;
        uniforms.lightPos.value.x = val.lightPos.x;
        uniforms.lightPos.value.y = val.lightPos.y;
        uniforms.lightPos.value.z = val.lightPos.z;

        console.log(uniforms.transparencyFactor.value);
        // uniforms.transparencyFactor.value = val.opacity;
    })
  },[mascotMat])
  
  return (
    <e.group theatreKey='Mascot' dispose={null}>
      {/* <mesh geometry={nodes.Sphere_1.geometry} material={material? material : materials.Tooth_Mixed_Material_2} position={[0, 2, 0]} rotation={[Math.PI / 2, 0, 0]}/> */}
      <mesh geometry={nodes.Sphere_1.geometry} material={
      //   new THREE.ShaderMaterial({
      //   uniforms,
      //   transparent:true,
      //   vertexShader,
      //   fragmentShader
      // }) 
      material
      } position={[0, 2, 0]} rotation={[Math.PI / 2, 0, 0]}/>
    </e.group>
  )
}

useGLTF.preload('/mascot-transformed.glb');
