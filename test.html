<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
<!-- Include Three.js library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<!-- Include GLSL noise library -->
<!-- <script src="https://unpkg.com/glsl-noise@0.0.2/index.js"></script> -->

<!-- Define your HTML canvas element -->
<canvas id="canvas"></canvas>

<!-- Vertex Shader -->
<script type="x-shader/x-vertex" id="vertexShader">
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
</script>

<!-- Fragment Shader -->
<script type="x-shader/x-fragment" id="fragmentShader">
    uniform sampler2D texture1;
    uniform sampler2D texture2;
    uniform float time;
    varying vec2 vUv;

    void main() {
        // Define the center of the swirl effect
        vec2 center = vec2(0.5, 0.5);

        // Calculate the UV coordinates
        vec2 uv = vUv;

        // Calculate the distance from the center
        vec2 delta = uv - center;

        // Calculate the angle of rotation
        float angle = atan(delta.y, delta.x);

        // Calculate the distance from the center to apply the swirl effect
        float distance = length(delta);

        // Define the radius and strength of the swirl effect
        float radius = 0.3;
        float strength = 0.5;

        // Calculate the new UV coordinates with the swirl effect
        uv = center + radius * vec2(cos(angle + strength * distance), sin(angle + strength * distance));

        // Interpolate between texture1 and texture2 based on time
        vec4 texel1 = texture2D(texture1, uv);
        vec4 texel2 = texture2D(texture2, uv);
        vec4 finalColor = mix(texel1, texel2, time);

        gl_FragColor = finalColor;
    }
</script>


<script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas') });
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    // Load your two textures
    const texture1 = new THREE.TextureLoader().load('./src/assets/Background.jpg');
    const texture2 = new THREE.TextureLoader().load('./src/assets/whiteLine.webp');
    
    // Define a plane geometry
    const geometry = new THREE.PlaneGeometry(2, 2);
    
    // Create a shader material
    const shaderMaterial = new THREE.ShaderMaterial({
        uniforms: {
            texture1: { type: 't', value: texture1 },
            texture2: { type: 't', value: texture2 },
            time: { type: 'f', value: 0.0 },
        },
        vertexShader: document.getElementById('vertexShader').textContent,
        fragmentShader: document.getElementById('fragmentShader').textContent,
    });
    
    // Create a mesh with the shader material
    const plane = new THREE.Mesh(geometry, shaderMaterial);
    scene.add(plane);
    
    // Set the camera position
    camera.position.z = 5;
    
    // Add the shader effect to the render loop
    const animate = () => {
        requestAnimationFrame(animate);
        
        // Update the time uniform for the shader
        shaderMaterial.uniforms.time.value += 0.01;
    
        renderer.render(scene, camera);
    };
    
    animate();
</script>

</body>
</html>