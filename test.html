<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Transparent Front and Back Faces</title>
  <style>
    *{ 
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    body{
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
    }
    canvas{
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 4;
    }
  </style>
</head>
<body>
    <h2>This Is a test</h2>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    // Set up scene, camera, and renderer
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    var renderer = new THREE.WebGLRenderer({alpha: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Create a cube geometry
    var geometry = new THREE.BoxGeometry(1, 1, 1);

    // Vertex Shader
    var vertexShader = `
      varying vec3 vNormal;

      void main() {
        vNormal = normalize(normalMatrix * normal);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    // Fragment Shader
    var fragmentShader = `
      varying vec3 vNormal;

    //   uniform vec3 cameraPosition; // Use cameraPosition instead of vViewPosition
      uniform float transparencyFactor;

      void main() {
        float dotProduct = dot(normalize(vNormal), normalize(vec3(5., 4., 3.) - gl_FragCoord.xyz));
        float transparency = 1.0 - abs(dotProduct);
        transparency = clamp(transparency, 0.0, 1.0);

        vec4 color = vec4(1.0, 0.0, 0.0, 1.0); // Red color
        gl_FragColor = vec4(color.rgb, transparency);
      }
    `;

    // Create a ShaderMaterial
    var material = new THREE.ShaderMaterial({
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      uniforms: {
        transparencyFactor: { value: 1. }, // Adjust this factor as needed
        cameraPosition: { value: camera.position } // Pass camera position to the shader
      },
      transparent: true,
    });

    // Create a mesh with the geometry and material
    var cube = new THREE.Mesh(geometry, material);
    cube.rotation.y = Math.PI/6
    scene.add(cube);

    // Set camera position
    camera.position.z = 5;

    // Create an animation loop
    var animate = function () {
      requestAnimationFrame(animate);

      // Rotate the cube
    //   cube.rotation.x += 0.01;
    //   cube.rotation.y += 0.01;

      renderer.render(scene, camera);
    };

    animate();
  </script>
</body>
</html>


/* eslint-disable react/prop-types */
/* eslint-disable react/no-unknown-property */
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.3 mascot.glb --transform
*/

<!-- import { useGLTF } from '@react-three/drei';
import React from 'react';
import {editable as e} from '@theatre/r3f';
import * as THREE from 'three';
import glossyTex from '../assets/glossy2.jpg';
import { useLoader } from '@react-three/fiber';
import { types as t } from "@theatre/core";


var vertexShader = `
  varying vec3 vNormal;
  varying vec2 vUv;

  void main() {
    vUv = uv;
    vNormal = normalize(normalMatrix * normal);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

// Fragment Shader
var fragmentShader = `
  varying vec3 vNormal;
  varying vec2 vUv;
  uniform sampler2D uTexture;
  uniform vec3 lightPos;
  uniform vec2 clampVal;
  uniform float material1;
  uniform float material2;
  uniform float opacity;

  void main() {
    float light = dot(vNormal, normalize(lightPos)) * 0.6 + 0.5;
    light = clamp(light, clampVal.x, clampVal.y);

    vec4 glossyMat = texture2D(uTexture, vUv);
    vec4 glossyColor = vec4(glossyMat.xyz, light);
    

    vec4 part1 = mix(vec4(light), glossyColor, material1);
    vec4 part2 = mix(part1, vec4(light), material2);
    vec4 final = mix(part2, part1, material2);
    gl_FragColor = part2;
  }
`;

export function Mascot({material, sheet}) {
  const ref = React.useRef();
  const { nodes, materials } = useGLTF('/mascot-transformed.glb');

  const texture = useLoader(THREE.TextureLoader, glossyTex);
  texture.colorSpace = THREE.SRGBColorSpace;

  const uniforms = {
    opacity: { value: 0. },
    material1: { value: 0. },
    material2: { value: 0. },
    uTexture: { value: texture },
    lightPos: {value: new THREE.Vector3(-1., -.2, -.8)},
    clampVal: {value: new THREE.Vector2(0., 1.)}
    // cameraPosition: { value: camera.position } // Pass camera position to the shader
  }

  const mascotMat = sheet.object('MascotMat',{
    opacity: t.number(0, {
        nudgeMultiplier: 0.1,
        range: [0, 1]
    }),
    clamp:{
      x: t.number(0, {
        nudgeMultiplier: 0.1,
        range: [0, 1]
      }),
      y: t.number(0, {
        nudgeMultiplier: 0.1,
        range: [0, 1]
      })
    },
    mat1: t.number(0, {
      nudgeMultiplier: 0.1,
      range: [0, 1]
    }),
    mat2: t.number(0, {
      nudgeMultiplier: 0.1,
      range: [0, 1]
    }),
    lightPos: {
      x: uniforms.lightPos.value.x,
      y: uniforms.lightPos.value.y,
      z: uniforms.lightPos.value.z
    },
  },{reconfigure: true});

  React.useEffect(()=>{
    mascotMat.onValuesChange(val=>{
        uniforms.opacity.value = val.opacity;
        uniforms.clampVal.value.x = val.clamp.x;
        uniforms.clampVal.value.y = val.clamp.y;
        uniforms.material1.value = val.mat1;
        uniforms.material2.value = val.mat2;
        uniforms.lightPos.value.x = val.lightPos.x;
        uniforms.lightPos.value.y = val.lightPos.y;
        uniforms.lightPos.value.z = val.lightPos.z;

        console.log(val.opacity)
        // uniforms.transparencyFactor.value = val.opacity;
    })
  },[mascotMat])
  
  return (
    <e.group theatreKey='Mascot' dispose={null}>
      {/* <mesh geometry={nodes.Sphere_1.geometry} material={material? material : materials.Tooth_Mixed_Material_2} position={[0, 2, 0]} rotation={[Math.PI / 2, 0, 0]}/> */}
      <mesh geometry={nodes.Sphere_1.geometry} material={new THREE.ShaderMaterial({
        uniforms,
        transparent:true,
        vertexShader,
        fragmentShader
      })} position={[0, 2, 0]} rotation={[Math.PI / 2, 0, 0]}/>
    </e.group>
  )
}

useGLTF.preload('/mascot-transformed.glb'); -->
